package controller_test

import (
	"context"
	"fmt"
	"time"

	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/service/ec2"
	ec2types "github.com/aws/aws-sdk-go-v2/service/ec2/types"
	"github.com/aws/smithy-go"
	. "github.com/onsi/ginkgo/v2"
	. "github.com/onsi/gomega"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sigs.k8s.io/controller-runtime/pkg/envtest/komega"
	"sigs.k8s.io/controller-runtime/pkg/reconcile"

	ec2operatorv1alpha1 "github.com/cloud-infra-group/ec2-operator/api/v1alpha1"
	"github.com/cloud-infra-group/ec2-operator/internal/controller"
	mock "github.com/cloud-infra-group/ec2-operator/internal/ec2client/ec2clientfakes"
)

// This test suite verifies the functionality of the AWSVPCEndpointService controller using a mock EC2 API client.
// The tests use Counterfeiter-generated mocks to simulate interactions with AWS services, enabling unit testing
// without requiring actual AWS resources. Counterfeiter allows generating mocks for interfaces, providing control
// over the behavior of external dependencies such as AWS SDKs during testing.

var _ = Describe("AWSVPCEndpointService Controller", func() {
	Context("When reconciling a resource", func() {
		const (
			waitShort       = 10 * time.Second
			pollingInterval = 500 * time.Millisecond
		)

		var (
			ctx context.Context
			// mockEC@Client is a mock AWS EC2 client generated by counterfieter
			mockEC2Client *mock.FakeEC2API
			// controllerReconciler is the controller these tests are for
			controllerReconciler  *controller.AWSVPCEndpointServiceReconciler
			typeNamespacedName    types.NamespacedName
			awsvpcendpointservice *ec2operatorv1alpha1.AWSVPCEndpointService
		)

		finalizerReconcile := func() {
			result, err := controllerReconciler.Reconcile(ctx, reconcile.Request{
				NamespacedName: typeNamespacedName,
			})
			Expect(err).NotTo(HaveOccurred())
			// expect a requeue since the first time should just be setting the finalizer
			Expect(result.IsZero()).To(BeFalse())

			// Verify the reconciler updated the resource status as expected.
			updatedResource := &ec2operatorv1alpha1.AWSVPCEndpointService{
				ObjectMeta: metav1.ObjectMeta{
					Name:      typeNamespacedName.Name,
					Namespace: typeNamespacedName.Namespace,
				},
			}
			Eventually(komega.Object(updatedResource), waitShort, pollingInterval).ShouldNot(HaveField("ObjectMeta.Finalizers", BeZero()))
		}

		ctx = context.Background()

		// Set the Kubernetes client for komega assertions.
		komega.SetClient(k8sClient)

		// Create an instance of the mock EC2 API client generated by Counterfeiter.
		// This mock allows us to define expected inputs and outputs for EC2 API methods during testing.
		mockEC2Client = &mock.FakeEC2API{}

		// Define a namespaced name for the test resource.
		typeNamespacedName = types.NamespacedName{
			Name:      "test-resource",
			Namespace: "default",
		}

		// Configure the reconciler to use the mock client and Kubernetes manager scheme.
		controllerReconciler = &controller.AWSVPCEndpointServiceReconciler{
			Client: k8sClient,
			Scheme: k8sManager.GetScheme(),
			EC2API: mockEC2Client,
		}

		BeforeEach(func() {
			By("creating the custom resource for the Kind AWSVPCEndpointService", func() {
				// Create a sample AWSVPCEndpointService resource to be used in tests.
				awsvpcendpointservice = &ec2operatorv1alpha1.AWSVPCEndpointService{
					ObjectMeta: metav1.ObjectMeta{
						Name:      typeNamespacedName.Name,
						Namespace: typeNamespacedName.Namespace,
					},
					Spec: ec2operatorv1alpha1.AWSVPCEndpointServiceSpec{
						NetworkLoadBalancerARN: "arn:aws:elasticloadbalancing:us-east-1:123456789012:loadbalancer/net/test-nlb/abcdef123456",
						AcceptanceRequired:     false,
						Tags: map[string]string{
							"Environment": "test",
						},
					},
				}
				// Ensure the resource is successfully created in the test environment
				Expect(k8sClient.Create(ctx, awsvpcendpointservice)).To(Succeed())
			})
		})

		AfterEach(func() {
			// Clean up the test resource from the test environment after each test.
			resource := &ec2operatorv1alpha1.AWSVPCEndpointService{}
			err := k8sClient.Get(ctx, typeNamespacedName, resource)
			Expect(client.IgnoreNotFound(err)).To(Succeed())
			if errors.IsNotFound(err) {
				return
			}

			resource.ObjectMeta.Finalizers = []string{}
			err = k8sClient.Update(ctx, resource)
			Expect(client.IgnoreNotFound(err)).To(Succeed())
			Eventually(komega.Object(resource), waitShort, pollingInterval).Should(HaveField("ObjectMeta.Finalizers", BeZero()))

			// reset the variable in order to ignore resource version
			resource = &ec2operatorv1alpha1.AWSVPCEndpointService{
				ObjectMeta: metav1.ObjectMeta{
					Name:      typeNamespacedName.Name,
					Namespace: typeNamespacedName.Namespace,
				},
			}
			err = k8sClient.Delete(ctx, resource)
			Expect(client.IgnoreNotFound(err)).To(Succeed())

			// Verify the resource is no longer present in the cluster.
			Eventually(func() error {
				_, err := komega.Object(resource)()
				return err
			}, waitShort, pollingInterval).Should(Satisfy(errors.IsNotFound))
		})

		It("should successfully reconcile the resource and create the VPC endpoint service", func() {
			const vpcID = "vpce-svc-0123456789abcdef"

			By("Reconciling the first time to set the finalizer", finalizerReconcile)

			// Use the mock EC2 client to simulate DescribeVpcEndpointServiceConfigurations returning no existing configurations.
			// This will satisfy the reconciler's call to the EC2 API to see if this endpoint service already exists.
			mockEC2Client.DescribeVpcEndpointServiceConfigurationsReturns(&ec2.DescribeVpcEndpointServiceConfigurationsOutput{
				ServiceConfigurations: []ec2types.ServiceConfiguration{
					{
						ServiceId: aws.String(vpcID),
					},
				},
			}, nil)

			// Simulate CreateVpcEndpointServiceConfiguration successfully creating a new service.
			// After the reconciler finds that the service endpoint does not exist, it should try to create it. This
			// tests a successful creation.
			mockEC2Client.CreateVpcEndpointServiceConfigurationReturns(&ec2.CreateVpcEndpointServiceConfigurationOutput{
				ServiceConfiguration: &ec2types.ServiceConfiguration{
					ServiceId: aws.String(vpcID),
				},
			}, nil)

			// Call the reconciler, which will use the mock client instead of the real AWS SDK.
			result, err := controllerReconciler.Reconcile(ctx, reconcile.Request{
				NamespacedName: typeNamespacedName,
			})
			Expect(err).NotTo(HaveOccurred())
			Expect(result.IsZero()).To(BeTrue())

			// Verify the mock client recorded the expected calls and only the expected calls.
			Expect(mockEC2Client.DescribeVpcEndpointServiceConfigurationsCallCount()).To(Equal(1))
			Expect(mockEC2Client.CreateVpcEndpointServiceConfigurationCallCount()).To(Equal(1))

			// Verify the reconciler updated the resource status as expected.
			updatedResource := &ec2operatorv1alpha1.AWSVPCEndpointService{
				ObjectMeta: metav1.ObjectMeta{
					Name:      typeNamespacedName.Name,
					Namespace: typeNamespacedName.Namespace,
				},
			}
			By(fmt.Sprintf("Waiting for AWSVPCEndpointService resource %s to be updated with the ServiceID", typeNamespacedName.Name))
			// The update of the cache is delayed.
			Eventually(komega.Object(updatedResource), waitShort, pollingInterval).Should(HaveField("Status.ServiceID", vpcID))
			Expect(updatedResource.Status.State).To(Equal("Available"))
		})

		It("should error if it can't create the VPC endpoint service", func() {
			By("Reconciling the first time to set the finalizer", finalizerReconcile)

			// Simulate DescribeVpcEndpointServiceConfigurations returning no existing configurations.
			// Again, the first API call that we expect the reeconciler to do is to check to see if the resource already
			// exists. We want to test when it does not.
			mockEC2Client.DescribeVpcEndpointServiceConfigurationsReturns(&ec2.DescribeVpcEndpointServiceConfigurationsOutput{
				ServiceConfigurations: []ec2types.ServiceConfiguration{},
			}, nil)

			// Simulate CreateVpcEndpointServiceConfiguration returning an error.
			// We don't know the full extent of the possible errors that EC2 might fail on, but as long as we test for _any_ error,
			// this should satisfy all the expected cases, so we'll return a made-up InvalidParamsError so we can check for it
			// in the return.
			mockEC2Client.CreateVpcEndpointServiceConfigurationReturns(nil, smithy.InvalidParamsError{Context: "test error"})

			// Call the reconciler, expecting it to handle the error gracefully.
			result, err := controllerReconciler.Reconcile(ctx, reconcile.Request{
				NamespacedName: typeNamespacedName,
			})
			Expect(err).To(HaveOccurred())
			Expect(result.IsZero()).To(BeTrue())

			// Verify the mock client recorded the expected calls and only the expected calls.
			Expect(mockEC2Client.DescribeVpcEndpointServiceConfigurationsCallCount()).To(Equal(1))
			Expect(mockEC2Client.CreateVpcEndpointServiceConfigurationCallCount()).To(Equal(1))
		})

		It("should delete the resource successfully", func() {
			const vpcID = "vpce-svc-0123456789abcdef"

			By("Reconciling the first time to set the finalizer", finalizerReconcile)

			By("Deleting the resource to set the deletion timestamp", func() {
				// Delete the resource and verify success.
				Expect(k8sClient.Delete(ctx, awsvpcendpointservice)).To(Succeed())
				updatedResource := &ec2operatorv1alpha1.AWSVPCEndpointService{
					ObjectMeta: metav1.ObjectMeta{
						Name:      typeNamespacedName.Name,
						Namespace: typeNamespacedName.Namespace,
					},
				}
				Eventually(komega.Object(updatedResource), waitShort, pollingInterval).ShouldNot(
					HaveField("ObjectMeta.DeletionTimestamp", BeZero()))
			})

			By("Reconciling the resource with the deletion timestamp set", func() {
				// Simulate DeleteVpcEndpointServiceConfigurations successfully deleting the configuration. This isn't
				// the entire response from EC2, but I think this is enough, for now, when testing that we successfully
				// deleted the resource.
				mockEC2Client.DeleteVpcEndpointServiceConfigurationsReturns(&ec2.DeleteVpcEndpointServiceConfigurationsOutput{
					Unsuccessful: nil,
				}, nil)

				// Call the reconciler, expecting it to handle the error gracefully.
				result, err := controllerReconciler.Reconcile(ctx, reconcile.Request{
					NamespacedName: typeNamespacedName,
				})

				Expect(err).NotTo(HaveOccurred())
				Expect(result.IsZero()).To(BeTrue())

				// Verify the mock client recorded the expected calls and only the expected calls.
				Expect(mockEC2Client.DescribeVpcEndpointServiceConfigurationsCallCount()).To(Equal(0))
				Expect(mockEC2Client.DeleteVpcEndpointServiceConfigurationsCallCount()).To(Equal(1))

				// Verify the resource is no longer present in the cluster.
				updatedResource := &ec2operatorv1alpha1.AWSVPCEndpointService{
					ObjectMeta: metav1.ObjectMeta{
						Name:      typeNamespacedName.Name,
						Namespace: typeNamespacedName.Namespace,
					},
				}
				By(fmt.Sprintf("Waiting for AWSVPCEndpointService resource %s to be deleted", typeNamespacedName.Name))
				Eventually(func() error {
					_, err := komega.Object(updatedResource)()
					return err
				}, waitShort, pollingInterval).Should(Satisfy(errors.IsNotFound))
			})
		})
	})
})
